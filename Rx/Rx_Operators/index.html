<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Rx_Operators (Rx.Rx_Operators)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../">Rx</a> &#x00BB; Rx_Operators</nav><h1>Module <code>Rx_Operators</code></h1></header><dl><dt class="spec type" id="type-unaryFunction"><a href="#type-unaryFunction" class="anchor"></a><code><span class="keyword">type</span> unaryFunction('a, 'b)</code><code> = <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span></code>;</dt><dt class="spec type" id="type-operator"><a href="#type-operator" class="anchor"></a><code><span class="keyword">type</span> operator('a, 'b)</code><code> = Rx_Observable.Observable.t(<span class="type-var">'a</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'b</span>)</code>;</dt></dl><dl><dt class="spec value" id="val-projectNoIdx"><a href="#val-projectNoIdx" class="anchor"></a><code><span class="keyword">let</span> projectNoIdx: <span>[&lt; <span>`Array<span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span></span> <span><span>| `Observable</span><span>(<span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span>)</span></span> <span><span>| `Promise</span><span>(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'f</span>)</span></span> <span><span>| `Repromise</span><span>(<span class="type-var">'g</span> <span>=&gt;</span> <span class="type-var">'h</span>)</span></span> ]</span> <span>=&gt;</span> <span>[&gt; <span>`Array<span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'i</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span></span> <span><span>| `Observable</span><span>(<span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'j</span> <span>=&gt;</span> <span class="type-var">'d</span>)</span></span> <span><span>| `Promise</span><span>(<span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'k</span> <span>=&gt;</span> <span class="type-var">'f</span>)</span></span> <span><span>| `Repromise</span><span>(<span class="type-var">'g</span> <span>=&gt;</span> <span class="type-var">'l</span> <span>=&gt;</span> <span class="type-var">'h</span>)</span></span> ]</span>;</code></dt></dl><dl><dt class="spec external" id="val-audit"><a href="#val-audit" class="anchor"></a><code><span class="keyword">let</span> audit: <span>[ <span>`Subscribable<span>(<span class="type-var">'a</span> <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'a</span>))</span></span> <span><span>| `Promise</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> Js.Promise.t(<span class="type-var">'a</span>))</span></span> <span><span>| `Repromise</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> Promise.t(<span class="type-var">'a</span>))</span></span> ]</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Ignores source values for a duration determined by another Observable, then emits the most recent value from the source Observable, then repeats this process.</p><dl><dt>parameter durationSelector</dt><dd><p>A function that receives a value from the source Observable, for computing the silencing duration, returned as an Observable or a Promise.</p></dd></dl><dl><dt>returns</dt><dd><p><code>Observable&lt;T&gt;</code> An Observable that performs rate-limiting of emissions from the source Observable.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-auditTime"><a href="#val-auditTime" class="anchor"></a><code><span class="keyword">let</span> auditTime: <span>duration:int</span> <span>=&gt;</span> <span>?&#8288;scheduler:Rx_Scheduler.t</span> <span>=&gt;</span> unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Ignores source values for `duration` milliseconds, then emits the most recent value from the source Observable, then repeats this process.</p><dl><dt>parameter duration</dt><dd><p>Time to wait before emitting the most recent source value, measured in milliseconds or the time unit determined internally by the optional `scheduler`.</p></dd></dl><dl><dt>parameter scheduler=async</dt><dd><p>The <code>@link SchedulerLike</code> to use for managing the timers that handle the rate-limiting behavior.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that performs rate-limiting of emissions from the source Observable.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-buffer"><a href="#val-buffer" class="anchor"></a><code><span class="keyword">let</span> buffer: Rx_Observable.Observable.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'b</span>, array(<span class="type-var">'b</span>))</span>;</code></dt><dd><p>Buffers the source Observable values until `closingNotifier` emits.</p><dl><dt>parameter {Observable&lt;any&gt;}</dt><dd><p>closingNotifier An Observable that signals the buffer to be emitted on the output Observable.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable of buffers, which are arrays of values.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-bufferCount"><a href="#val-bufferCount" class="anchor"></a><code><span class="keyword">let</span> bufferCount: <span>bufferSize:int</span> <span>=&gt;</span> <span>?&#8288;startBufferEvery:int</span> <span>=&gt;</span> unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, array(<span class="type-var">'a</span>))</span>;</code></dt><dd><p>Buffers the source Observable values until the size hits the maximum `bufferSize` given.</p><dl><dt>parameter bufferSize</dt><dd><p>The maximum size of the buffer emitted.</p></dd></dl><dl><dt>parameter startBufferEvery</dt><dd><p>Interval at which to start a new buffer. For example if `startBufferEvery` is `2`, then a new buffer will be started on every other value from the source. A new buffer is started at the beginning of the source by default.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable of arrays of buffered values</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-bufferTime"><a href="#val-bufferTime" class="anchor"></a><code><span class="keyword">let</span> bufferTime: <span>timeSpan:int</span> <span>=&gt;</span> <span>?&#8288;bufferCreationInterval:int</span> <span>=&gt;</span> <span>?&#8288;maxBufferSize:int</span> <span>=&gt;</span> <span>?&#8288;scheduler:Rx_Scheduler.t</span> <span>=&gt;</span> unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, array(<span class="type-var">'a</span>))</span>;</code></dt><dd><p>Buffers the source Observable values for a specific time period.</p><dl><dt>parameter bufferTimeSpan</dt><dd><p>The amount of time to fill each buffer array.</p></dd></dl><dl><dt>parameter bufferCreationInterval</dt><dd><p>The interval at which to start new buffers.</p></dd></dl><dl><dt>parameter maxBufferSize</dt><dd><p>The maximum buffer size.</p></dd></dl><dl><dt>parameter scheduler(async)</dt><dd><p>The scheduler on which to schedule the intervals that determine buffer boundaries.</p></dd></dl><dl><dt>returns</dt><dd><p>An observable of arrays of buffered values.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-bufferToggle"><a href="#val-bufferToggle" class="anchor"></a><code><span class="keyword">let</span> bufferToggle: <span>opening:<span>[ <span>`Subscribable<span>(Rx_Observable.Observable.t(<span class="type-var">'o</span>))</span></span> <span><span>| `Promise</span><span>(Js.Promise.t(<span class="type-var">'o</span>))</span></span> <span><span>| `Repromise</span><span>(Promise.t(<span class="type-var">'o</span>))</span></span> ]</span></span> <span>=&gt;</span> <span>closing:<span>[ <span>`Subscribable<span>(<span class="type-var">'o</span> <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'c</span>))</span></span> <span><span>| `Promise</span><span>(<span class="type-var">'o</span> <span>=&gt;</span> Js.Promise.t(<span class="type-var">'c</span>))</span></span> <span><span>| `Repromise</span><span>(<span class="type-var">'o</span> <span>=&gt;</span> Promise.t(<span class="type-var">'c</span>))</span></span> ]</span></span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, array(<span class="type-var">'a</span>))</span>;</code></dt><dd><p>Buffers the source Observable values starting from an emission from `openings` and ending when the output of `closingSelector` emits</p><dl><dt>parameter openings</dt><dd><p>A Subscribable or Promise of notifications to start new buffers</p></dd></dl><dl><dt>parameter closingSelector</dt><dd><p>A function that takes the value emitted by the `openings` observable and returns a Subscribable or Promise which, when it emits, signals that the associated buffer should be emitted and cleared</p></dd></dl><dl><dt>returns</dt><dd><p>An observable of arrays of buffered values</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-bufferWhen"><a href="#val-bufferWhen" class="anchor"></a><code><span class="keyword">let</span> bufferWhen: <span>(unit <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'b</span>))</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, array(<span class="type-var">'a</span>))</span>;</code></dt><dd><p>Buffers the source Observable values, using a factory function of closing Observables to determine when to close, emit, and reset the buffer.</p><dl><dt>parameter closingSelector</dt><dd><p>A function that takes no arguments and returns an Observable that signals buffer closure.</p></dd></dl><dl><dt>returns</dt><dd><p>An observable of arrays of buffered values.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-catchError"><a href="#val-catchError" class="anchor"></a><code><span class="keyword">let</span> catchError: <span>(<span class="type-var">'err</span> <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'a</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'b</span>))</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p>Catches errors on the observable to be handled by returning a new observable or throwing an error.</p><dl><dt>parameter selector</dt><dd><p>a function that takes as arguments `err`, which is the error, and `caught`, which is the source observable, in case you'd like to &quot;retry&quot; that observable by returning it again. Whatever observable is returned by the `selector` will be used to continue the observable chain.</p></dd></dl><dl><dt>returns</dt><dd><p>An observable that originates from either the source or the observable returned by the catch `selector` function.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-combineAll"><a href="#val-combineAll" class="anchor"></a><code><span class="keyword">let</span> combineAll: unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>), array(<span class="type-var">'a</span>))</span>;</code></dt><dd><p>Flattens an Observable-of-Observables by applying <code>@link combineLatest</code> when the Observable-of-Observables completes. `combineAll` takes an Observable of Observables, and collects all Observables from it. Once the outer Observable completes, it subscribes to all collected Observables and combines their values using the <code>@link combineLatest</code>&lt;/a&gt; strategy, such that:</p><p>Every time an inner Observable emits, the output Observable emits When the returned observable emits, it emits all of the latest values by: an array of all the most recent values is emitted by the output Observable.</p><p>@see combineAllProject</p></dd></dl><dl><dt class="spec external" id="val-_combineAllProject"><a href="#val-_combineAllProject" class="anchor"></a><code><span class="keyword">let</span> _combineAllProject: Js.Internal.fn<span>(<span>[ <span>`Arity_1<span>(array(<span class="type-var">'a</span>) <span>=&gt;</span> <span class="type-var">'r</span>)</span></span> ]</span>, <a href="#type-operator">operator</a><span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>), <span class="type-var">'r</span>)</span>)</span>;</code></dt></dl><dl><dt class="spec type" id="type-projectFn"><a href="#type-projectFn" class="anchor"></a><code><span class="keyword">type</span> projectFn('a, 'r)</code><code> = <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'r</span></code>;</dt></dl><dl><dt class="spec value" id="val-combineAllProject"><a href="#val-combineAllProject" class="anchor"></a><code><span class="keyword">let</span> combineAllProject: <a href="#type-projectFn">projectFn</a><span>(array(<span class="type-var">'a</span>), <span class="type-var">'r</span>)</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>), <span class="type-var">'r</span>)</span>;</code></dt><dd><p>Flattens an Observable-of-Observables by applying <code>@link combineLatest</code> when the Observable-of-Observables completes. `combineAll` takes an Observable of Observables, and collects all Observables from it. Once the outer Observable completes, it subscribes to all collected Observables and combines their values using the <code>@link combineLatest</code>&lt;/a&gt; strategy, such that:</p><p>Every time an inner Observable emits, the output Observable emits When the returned observable emits, it emits all of the latest values by: it is called with each recent value from each inner Observable in whatever order they arrived, and the result of the `project` function is what is emitted by the output Observable.</p><dl><dt>parameter project</dt><dd><p>function to map the most recent values from each inner Observable into a new result. @see combineAll</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-concatAll"><a href="#val-concatAll" class="anchor"></a><code><span class="keyword">let</span> concatAll: unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>), <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Converts a higher-order Observable into a first-order Observable by concatenating the inner Observables in order.</p><p>Joins every Observable emitted by the source (a higher-order Observable), in a serial fashion. It subscribes to each inner Observable only after the previous inner Observable has completed, and merges all of their values into the returned observable.</p><dl><dt>returns</dt><dd><p>An Observable emitting values from all the inner Observables concatenated.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-concatMap"><a href="#val-concatMap" class="anchor"></a><code><span class="keyword">let</span> concatMap: <span>[ <span>`Observable<span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Promise</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Js.Promise.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Repromise</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Promise.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Array</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> array(<span class="type-var">'b</span>))</span></span> ]</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p>Projects each source value to an Observable which is merged in the output Observable, in a serialized fashion waiting for each one to complete before merging the next.</p><p>Returns an Observable that emits items based on applying a function that you supply to each item emitted by the source Observable, where that function returns an (so-called &quot;inner&quot;) Observable. Each new inner Observable is concatenated with the previous inner Observable.</p><dl><dt>parameter project</dt><dd><p>A function that, when applied to an item emitted by the source Observable, returns an Observable</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits the result of applying the projection function (and the optional deprecated `resultSelector`) to each item emitted by the source Observable and taking values from each projected inner Observable sequentially.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-concatMapn"><a href="#val-concatMapn" class="anchor"></a><code><span class="keyword">let</span> concatMapn: <span>[&lt; <span>`Array<span>(<span class="type-var">'a</span> <span>=&gt;</span> array(<span class="type-var">'b</span>))</span></span> <span><span>| `Observable</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Promise</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> Js.Promise.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Repromise</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> Promise.t(<span class="type-var">'b</span>))</span></span> ]</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt></dl><dl><dt class="spec external" id="val-concatMapTo"><a href="#val-concatMapTo" class="anchor"></a><code><span class="keyword">let</span> concatMapTo: <span>[ <span>`Observable<span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>))</span></span> <span><span>| `Promise</span><span>(Js.Promise.t(<span class="type-var">'a</span>))</span></span> <span><span>| `Repromise</span><span>(Promise.t(<span class="type-var">'a</span>))</span></span> <span><span>| `Array</span><span>(array(<span class="type-var">'a</span>))</span></span> ]</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'b</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Projects each source value to the same Observable which is merged multiple times in a serialized fashion on the output Observable. convinience for concatMap(() =&gt; innerObservable)</p><p>Maps each source value to the given Observable `innerObservable` regardless of the source value, and then flattens those resulting Observables into one single Observable, which is the output Observable. Each new `innerObservable` instance emitted on the output Observable is concatenated with the previous `innerObservable` instance.</p><dl><dt>parameter innerObservable</dt><dd><p>An Observable to replace each value from the source Observable.</p></dd></dl><dl><dt>returns</dt><dd><p>An observable of values merged together by joining the passed observable with itself, one after the other, for each value emitted from the source.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-_count"><a href="#val-_count" class="anchor"></a><code><span class="keyword">let</span> _count: <span>predicate:<span>(<span>value:<span class="type-var">'a</span></span> <span>=&gt;</span> <span>index:int</span> <span>=&gt;</span> <span>source:Rx_Observable.Observable.t(<span class="type-var">'a</span>)</span> <span>=&gt;</span> bool)</span></span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, int)</span>;</code></dt><dd><p>Emits all of the values from the source observable, then, once it completes, subscribes to each observable source provided, one at a time, emitting all of their values, and not subscribing to the next one until it completes.</p><dl><dt>parameter otherSources</dt><dd><p>Other observable sources to subscribe to, in sequence, after the original source is complete.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits the result of applying the projection function (and the optional deprecated `resultSelector`) to each item emitted by the source Observable and taking values from each projected inner Observable sequentially.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">let</span> count: <span>?&#8288;predicate:<span>(<span>value:<span class="type-var">'a</span></span> <span>=&gt;</span> <span>index:int</span> <span>=&gt;</span> <span>source:Rx_Observable.Observable.t(<span class="type-var">'a</span>)</span> <span>=&gt;</span> bool)</span></span> <span>=&gt;</span> unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, int)</span>;</code></dt><dd><p>Counts the number of emissions on the source and emits that number when the source completes.</p><p>`count` transforms an Observable that emits values into an Observable that emits a single value that represents the number of values emitted by the source Observable. If the source Observable terminates with an error, `count` will pass this error notification along without emitting a value first. If the source Observable does not terminate at all, `count` will neither emit a value nor terminate. This operator takes an optional `predicate` function as argument, in which case the output emission will represent the number of source values that matched `true` with the `predicate`.</p><dl><dt>parameter predicate</dt><dd><p>boolean function to select what values are to be counted</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable of one number that represents the count as described above.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-debounce"><a href="#val-debounce" class="anchor"></a><code><span class="keyword">let</span> debounce: <span>durationSelector:<span>[ <span>`Subscribable<span>(<span class="type-var">'a</span> <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'a</span>))</span></span> <span><span>| `Promise</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> Js.Promise.t(<span class="type-var">'a</span>))</span></span> <span><span>| `Repromise</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> Promise.t(<span class="type-var">'a</span>))</span></span> ]</span></span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Emits a notification from the source Observable only after a particular time span determined by another Observable has passed without another source emission.</p><dl><dt>parameter durationSelector</dt><dd><p>A function that receives a value from the source Observable, for computing the timeout duration for each source value, returned as an Observable or a Promise.</p></dd></dl><dl><dt>returns</dt><dd><p><code>Observable</code> An Observable that delays the emissions of the source Observable by the specified duration Observable returned by `durationSelector`, and may drop some values if they occur too frequently.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-debounceTime"><a href="#val-debounceTime" class="anchor"></a><code><span class="keyword">let</span> debounceTime: <span>dueTime:float</span> <span>=&gt;</span> <span>?&#8288;scheduler:Rx_Scheduler.t</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Emits a notification from the source Observable only after a particular time span has passed without another source emission.</p><dl><dt>parameter The</dt><dd><p>timeout duration in milliseconds (or the time unit determined internally by the optional `scheduler`) for the window of time required to wait for emission silence before emitting the most recent source value.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that delays the emissions of the source Observable by the specified `dueTime`, and may drop some values if they occur too frequently.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-defaultIfEmpty"><a href="#val-defaultIfEmpty" class="anchor"></a><code><span class="keyword">let</span> defaultIfEmpty: <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Emits a given value if the source Observable completes without emitting any `next` value, otherwise mirrors the source Observable.</p><dl><dt>parameter The</dt><dd><p>default value used if the source Observable is empty.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits either the specified `defaultValue` if the source Observable emits no items, or the values emitted by the source Observable</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-delay"><a href="#val-delay" class="anchor"></a><code><span class="keyword">let</span> delay: <span>[ <span>`Int<span>(int)</span></span> <span><span>| `Date</span><span>(Js.Date.t)</span></span> ]</span> <span>=&gt;</span> <span>?&#8288;scheduler:Rx_Scheduler.t</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Delays the emission of items from the source Observable by a given timeout or until a given Date.</p><dl><dt>parameter delay</dt><dd><p>duration in milliseconds (a `number`) or a `Date` until which the emission of the source items is delayed</p></dd></dl><dl><dt>parameter scheduler</dt><dd><p>The <code>@link SchedulerLike</code> to use for managing the timers that handle the time-shift for each item</p></dd></dl><dl><dt>returns</dt><dd><p>The <code>@link SchedulerLike</code> to use for managing the timers that handle the time-shift for each item</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-delayWhen"><a href="#val-delayWhen" class="anchor"></a><code><span class="keyword">let</span> delayWhen: <span>delayDurationSelector:<span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'b</span>))</span></span> <span>=&gt;</span> <span>?&#8288;subscriptionDelay:Rx_Observable.Observable.t(<span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Delays the emission of items from the source Observable by a given time span determined by the emissions of another Observable</p><dl><dt>parameter delayDurationSelector</dt><dd><p>A function that returns an Observable for each value emitted by the source Observable, which is then used to delay the emission of that item on the output Observable until the Observable returned from this function emits a value</p></dd></dl><dl><dt>parameter subscriptionDelay</dt><dd><p>An Observable that triggers the subscription to the source Observable once it emits any value</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that delays the emissions of the source Observable by an amount of time specified by the Observable returned by `delayDurationSelector`</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-dematerialize"><a href="#val-dematerialize" class="anchor"></a><code><span class="keyword">let</span> dematerialize: unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(Rx_Notification.t(<span class="type-var">'a</span>), <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Converts an Observable of Notification objects into the emissions that they represent</p></dd></dl><dl><dt class="spec external" id="val-_distinct"><a href="#val-_distinct" class="anchor"></a><code><span class="keyword">let</span> _distinct: <span>keySelector:<span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span></span> <span>=&gt;</span> <span>?&#8288;flushes:Rx_Observable.Observable.t(<span class="type-var">'f</span>)</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt></dl><dl><dt class="spec value" id="val-distinct"><a href="#val-distinct" class="anchor"></a><code><span class="keyword">let</span> distinct: <span>?&#8288;keySelector:<span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span></span> <span>=&gt;</span> <span>?&#8288;flushes:Rx_Observable.Observable.t(<span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items</p><p>If a keySelector function is provided, then it will project each value from the source observable into a new value that it will check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the source observable directly with an equality check against previous values</p><dl><dt>parameter keySelector</dt><dd><p>function to select which value you want to check as distinct</p></dd></dl><dl><dt>parameter flushes</dt><dd><p>Optional Observable for flushing the internal HashSet of the operator</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits items from the source Observable with distinct values</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-_distinctUntilChanged"><a href="#val-_distinctUntilChanged" class="anchor"></a><code><span class="keyword">let</span> _distinctUntilChanged: <span>compare:<span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> bool)</span></span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt></dl><dl><dt class="spec value" id="val-distinctUntilChanged"><a href="#val-distinctUntilChanged" class="anchor"></a><code><span class="keyword">let</span> distinctUntilChanged: <span>?&#8288;compare:<span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> bool)</span></span> <span>=&gt;</span> unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item. If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted. If a comparator function is not provided, an equality check(shallow) is used by default.</p><dl><dt>parameter compare</dt><dd><p>Optional comparison function called to test if an item is distinct from the previous item in the source.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits items from the source Observable with distinct values.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-_distinctUntilKeyChanged"><a href="#val-_distinctUntilKeyChanged" class="anchor"></a><code><span class="keyword">let</span> _distinctUntilKeyChanged: <span>key:string</span> <span>=&gt;</span> <span>compare:<span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> bool)</span></span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item using a property accessed by using the key provided to check if the two items are distinct.</p><p>If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted. If a comparator function is not provided, an equality check(shallow) is used by default.</p></dd></dl><dl><dt class="spec value" id="val-distinctUntilKeyChanged"><a href="#val-distinctUntilKeyChanged" class="anchor"></a><code><span class="keyword">let</span> distinctUntilKeyChanged: <span>key:string</span> <span>=&gt;</span> <span>?&#8288;compare:<span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> bool)</span></span> <span>=&gt;</span> unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt></dl><dl><dt class="spec external" id="val-elementAt"><a href="#val-elementAt" class="anchor"></a><code><span class="keyword">let</span> elementAt: int <span>=&gt;</span> <span>?&#8288;default:<span class="type-var">'a</span></span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Emits the single value at the specified `index` in a sequence of emissions from the source Observable</p><dl><dt>parameter index</dt><dd><p>Is the number `i` for the i-th source emission that has happened since the subscription, starting from the number `0`.</p></dd></dl><dl><dt>parameter default</dt><dd><p>The default value returned for missing indices.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits a single item, if it is found.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-endWith"><a href="#val-endWith" class="anchor"></a><code><span class="keyword">let</span> endWith: array(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Returns an Observable that emits the items you specify as arguments after it finishes emitting items emitted by the source Observable.</p><dl><dt>parameter items</dt><dd><p>Items you want the modified Observable to emit last.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits the items emitted by the source Observable and then emits the items in the specified Iterable.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-every"><a href="#val-every" class="anchor"></a><code><span class="keyword">let</span> every: <span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'a</span>) <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Returns an Observable that emits whether or not every item of the source satisfies the condition specified.</p><dl><dt>parameter predicate</dt><dd><p>A function for determining if an item meets a specified condition</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable of booleans that determines if all items of the source Observable meet the condition specified</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-exhaust"><a href="#val-exhaust" class="anchor"></a><code><span class="keyword">let</span> exhaust: unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>), <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Converts a higher-order Observable into a first-order Observable by dropping inner Observables while the previous inner Observable has not yet completed.</p><p>`exhaust` ignores every new inner Observable if the previous Observable has not yet completed. Once that one completes, it will accept and flatten the next inner Observable and repeat this process.</p><dl><dt>returns</dt><dd><p>An Observable that takes a source of Observables and propagates the first observable exclusively until it completes before subscribing to the next.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-exhaustMap"><a href="#val-exhaustMap" class="anchor"></a><code><span class="keyword">let</span> exhaustMap: <span>[ <span>`Observable<span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Promise</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Js.Promise.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Repromise</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Promise.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Array</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> array(<span class="type-var">'b</span>))</span></span> ]</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p>Projects each source value to an Observable which is merged in the output Observable only if the previous projected Observable has completed.</p><dl><dt>parameter project</dt><dd><p>A function that, when applied to an item emitted by the source Observable, returns an Observable or Promise or iterable.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable containing projected Observables of each item of the source, ignoring projected Observables that start before their preceding Observable has completed.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-exhaustMapn"><a href="#val-exhaustMapn" class="anchor"></a><code><span class="keyword">let</span> exhaustMapn: <span>[&lt; <span>`Array<span>(<span class="type-var">'a</span> <span>=&gt;</span> array(<span class="type-var">'b</span>))</span></span> <span><span>| `Observable</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Promise</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> Js.Promise.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Repromise</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> Promise.t(<span class="type-var">'b</span>))</span></span> ]</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt></dl><dl><dt class="spec external" id="val-expand"><a href="#val-expand" class="anchor"></a><code><span class="keyword">let</span> expand: <span>[ <span>`Observable<span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Promise</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Js.Promise.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Repromise</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Promise.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Array</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> array(<span class="type-var">'b</span>))</span></span> ]</span> <span>=&gt;</span> <span>?&#8288;concurrent:int</span> <span>=&gt;</span> <span>?&#8288;scheduler:Rx_Scheduler.t</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p>Recursively projects each source value to an Observable which is merged in the output Observable.</p><dl><dt>parameter project</dt><dd><p>A function that, when applied to an item emitted by the source or the output Observable, returns an Observable.</p></dd></dl><dl><dt>parameter cuncurrent</dt><dd><p>Maximum number of input Observables being subscribed to concurrently.</p></dd></dl><dl><dt>parameter scheduler</dt><dd><p>The `Scheduler` to use for subscribing to each projected inner Observable.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits the source values and also result of applying the projection function to each value emitted on the output Observable and merging the results of the Observables obtained from this transformation.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-expandn"><a href="#val-expandn" class="anchor"></a><code><span class="keyword">let</span> expandn: <span>[&lt; <span>`Array<span>(<span class="type-var">'a</span> <span>=&gt;</span> array(<span class="type-var">'b</span>))</span></span> <span><span>| `Observable</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Promise</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> Js.Promise.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Repromise</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> Promise.t(<span class="type-var">'b</span>))</span></span> ]</span> <span>=&gt;</span> <span>?&#8288;concurrent:int</span> <span>=&gt;</span> <span>?&#8288;scheduler:Rx_Scheduler.t</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt></dl><dl><dt class="spec external" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">let</span> filter: <span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Filter items emitted by the source Observable by only emitting those that satisfy a specified predicate</p><dl><dt>parameter predicate</dt><dd><p>A function that evaluates each value emitted by the source Observable.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-filtern"><a href="#val-filtern" class="anchor"></a><code><span class="keyword">let</span> filtern: <span>(<span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt></dl><dl><dt class="spec external" id="val-finalize"><a href="#val-finalize" class="anchor"></a><code><span class="keyword">let</span> finalize: <span>(unit <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Returns an Observable that mirrors the source Observable, but will call a specified function when the source terminates on complete or error.</p><dl><dt>parameter callback</dt><dd><p>Function to be called when source terminates.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that mirrors the source, but will call the specified function on termination.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">let</span> find: <span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'a</span>) <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Emits only the first value emitted by the source Observable that meets some condition.</p><dl><dt>parameter predicate</dt><dd><p>A function called with each item to test for condition matching.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable of the first item that matches the condition</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-findIndex"><a href="#val-findIndex" class="anchor"></a><code><span class="keyword">let</span> findIndex: <span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'a</span>) <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, int)</span>;</code></dt><dd><p>Emits only the index of the first value emitted by the source Observable that meets some condition.</p><dl><dt>parameter predicate</dt><dd><p>A function called with each item to test for condition matching</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable of the index of the first item that matches the condition.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-_first"><a href="#val-_first" class="anchor"></a><code><span class="keyword">let</span> _first: <span>predicate:<span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'a</span>) <span>=&gt;</span> bool)</span></span> <span>=&gt;</span> <span>?&#8288;defaultValue:<span class="type-var">'b</span></span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt></dl><dl><dt class="spec value" id="val-first"><a href="#val-first" class="anchor"></a><code><span class="keyword">let</span> first: <span>?&#8288;predicate:<span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'a</span>) <span>=&gt;</span> bool)</span></span> <span>=&gt;</span> <span>?&#8288;defaultValue:<span class="type-var">'b</span></span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p>Emits only the first value (or the first value that meets some condition) emitted by the source Observable.</p><dl><dt>parameter predicate</dt><dd><p>An optional function called with each item to test for condition matching.</p></dd></dl><dl><dt>parameter The</dt><dd><p>default value emitted in case no valid value was found on the source.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable of the first item that matches the condition</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-groupBy"><a href="#val-groupBy" class="anchor"></a><code><span class="keyword">let</span> groupBy: <span>(<span class="type-var">'a</span> <span>=&gt;</span> string)</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, Rx_Observable.Observable.t(<span class="type-var">'b</span>))</span>;</code></dt><dd><p>Groups the items emitted by an Observable according to a specified criterion, and emits these grouped items as `GroupedObservables`, one per group.</p><p>When the Observable emits an item, a key is computed for this item with the keySelector function. If a GroupedObservable for this key exists, this roupedObservable emits. Elsewhere, a new GroupedObservable for this key is created and emits.</p><dl><dt>parameter keySelector</dt><dd><p>A function that extracts the key for each item.</p></dd></dl><dl><dt>parameter elementSelector</dt><dd><p>A function that extracts the return element for each item.</p></dd></dl><dl><dt>parameter durationSelectorA</dt><dd><p>function that returns an Observable to determine how long each group should exist.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits GroupedObservables, each of which corresponds to a unique key value and each of which emits those items from the source Observable that share that key</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-groupByWithElementSelector"><a href="#val-groupByWithElementSelector" class="anchor"></a><code><span class="keyword">let</span> groupByWithElementSelector: <span>(<span class="type-var">'a</span> <span>=&gt;</span> string)</span> <span>=&gt;</span> <span>elementSelector:<span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span></span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, Rx_Observable.Observable.t(<span class="type-var">'b</span>))</span>;</code></dt><dt class="spec external" id="val-groupByWithElementDurationSelector"><a href="#val-groupByWithElementDurationSelector" class="anchor"></a><code><span class="keyword">let</span> groupByWithElementDurationSelector: <span>(<span class="type-var">'a</span> <span>=&gt;</span> string)</span> <span>=&gt;</span> <span>elementSelector:<span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span></span> <span>=&gt;</span> <span>durationSelector:<span>(Rx_Observable.Observable.t(<span class="type-var">'b</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'c</span>))</span></span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, Rx_Observable.Observable.t(<span class="type-var">'b</span>))</span>;</code></dt><dt class="spec external" id="val-groupByWithElementDurationSubjectSelector"><a href="#val-groupByWithElementDurationSubjectSelector" class="anchor"></a><code><span class="keyword">let</span> groupByWithElementDurationSubjectSelector: <span>(<span class="type-var">'a</span> <span>=&gt;</span> string)</span> <span>=&gt;</span> <span>elementSelector:<span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span></span> <span>=&gt;</span> <span>durationSelector:<span>(Rx_Observable.Observable.t(<span class="type-var">'b</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'c</span>))</span></span> <span>=&gt;</span> <span>subjectSelector:<span>(unit <span>=&gt;</span> Rx_Subject.t(<span class="type-var">'b</span>))</span></span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, Rx_Observable.Observable.t(<span class="type-var">'b</span>))</span>;</code></dt><dt class="spec external" id="val-ignoreElements"><a href="#val-ignoreElements" class="anchor"></a><code><span class="keyword">let</span> ignoreElements: unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.</p><dl><dt>returns</dt><dd><p>An empty Observable that only calls `complete` or `error`, based on which one is called by the source Observable.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-isEmpty"><a href="#val-isEmpty" class="anchor"></a><code><span class="keyword">let</span> isEmpty: unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, bool)</span>;</code></dt><dd><p>Emits `false` if the input Observable emits any values, or emits `true` if the input Observable completes without emitting any values</p><dl><dt>returns</dt><dd><p>An Observable of a boolean value indicating whether observable was empty or not.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-_last"><a href="#val-_last" class="anchor"></a><code><span class="keyword">let</span> _last: <span>predicate:<span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'a</span>) <span>=&gt;</span> bool)</span></span> <span>=&gt;</span> <span>?&#8288;defaultValue:<span class="type-var">'b</span></span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt></dl><dl><dt class="spec value" id="val-last"><a href="#val-last" class="anchor"></a><code><span class="keyword">let</span> last: <span>?&#8288;predicate:<span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'a</span>) <span>=&gt;</span> bool)</span></span> <span>=&gt;</span> <span>?&#8288;defaultValue:<span class="type-var">'b</span></span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p>Emits only the last value (or the last value that meets some condition) emitted by the source Observable.</p><dl><dt>parameter predicate</dt><dd><p>An optional function called with each item to test for condition matching.</p></dd></dl><dl><dt>parameter The</dt><dd><p>default value emitted in case no valid value was found on the source.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable of the last item that matches the condition</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">let</span> map: <span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p>Applies a given `project` function to each value emitted by the source Observable and emits the resulting values as an Observable.</p><dl><dt>parameter project</dt><dd><p>The function to apply to each `value` emitted by the source Observable. The `index` parameter is the number `i` for the i-th emission that has happened since the subscription, starting from the number `0`.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits the values from the source Observable transformed by the given `project` function.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-mapn"><a href="#val-mapn" class="anchor"></a><code><span class="keyword">let</span> mapn: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt></dl><dl><dt class="spec external" id="val-mapTo"><a href="#val-mapTo" class="anchor"></a><code><span class="keyword">let</span> mapTo: <span class="type-var">'b</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p>Emits the given constant value on the output Observable every time the source Observable emits a value.</p><dl><dt>parameter value</dt><dd><p>The value to map each source value to.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits the given value every time the source Observable emits something.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-materialize"><a href="#val-materialize" class="anchor"></a><code><span class="keyword">let</span> materialize: unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, Rx_Notification.t(<span class="type-var">'a</span>))</span>;</code></dt><dd><p>Represents all of the notifications from the source Observable as `next` emissions marked with their original types within Notification objects.</p><dl><dt>returns</dt><dd><p>An Observable that emits objects that wrap the original emissions from the source Observable with metadata.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-max"><a href="#val-max" class="anchor"></a><code><span class="keyword">let</span> max: unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function)and when source Observable completes it emits a single item: the item with the largest value.</p><dl><dt>returns</dt><dd><p>An Observable that emits item with the largest value.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-maxWithComparer"><a href="#val-maxWithComparer" class="anchor"></a><code><span class="keyword">let</span> maxWithComparer: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> float)</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function)and when source Observable completes it emits a single item: the item with the largest value.</p><dl><dt>parameter Optional</dt><dd><p>comparer function that it will use instead of its default to compare the value of two items.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits item with the largest value.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-mergeAll"><a href="#val-mergeAll" class="anchor"></a><code><span class="keyword">let</span> mergeAll: <span>?&#8288;concurrent:int</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>), <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Converts a higher-order Observable into a first-order Observable which concurrently delivers all values that are emitted on the inner Observables.</p><dl><dt>parameter Maximum</dt><dd><p>number of inner Observables being subscribed to concurrently.</p></dd></dl><dl><dt>returns</dt><dd><p><code>Observable</code> An Observable that emits values coming from all the inner Observables emitted by the source Observable.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-mergeMap"><a href="#val-mergeMap" class="anchor"></a><code><span class="keyword">let</span> mergeMap: <span>[ <span>`Observable<span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Promise</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Js.Promise.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Repromise</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Promise.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Array</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> array(<span class="type-var">'b</span>))</span></span> ]</span> <span>=&gt;</span> <span>?&#8288;concurrent:int</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p>Projects each source value to an Observable which is merged in the output Observable.</p><dl><dt>parameter project</dt><dd><p>A function that, when applied to an item emitted by the source Observable, returns an Observable.</p></dd></dl><dl><dt>parameter Maximum</dt><dd><p>number of input Observables being subscribed to concurrently.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits the result of applying the projection function (and the optional deprecated `resultSelector`) to each item emitted by the source Observable and merging the results of the Observables obtained from this transformation.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-mergeMapn"><a href="#val-mergeMapn" class="anchor"></a><code><span class="keyword">let</span> mergeMapn: <span>[&lt; <span>`Array<span>(<span class="type-var">'a</span> <span>=&gt;</span> array(<span class="type-var">'b</span>))</span></span> <span><span>| `Observable</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Promise</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> Js.Promise.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Repromise</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> Promise.t(<span class="type-var">'b</span>))</span></span> ]</span> <span>=&gt;</span> <span>?&#8288;concurrent:int</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt></dl><dl><dt class="spec external" id="val-mergeMapTo"><a href="#val-mergeMapTo" class="anchor"></a><code><span class="keyword">let</span> mergeMapTo: <span>[ <span>`Observable<span>(Rx_Observable.Observable.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Promise</span><span>(Js.Promise.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Repromise</span><span>(Promise.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Array</span><span>(array(<span class="type-var">'b</span>))</span></span> ]</span> <span>=&gt;</span> <span>?&#8288;concurrent:int</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p>Projects each source value to the same Observable which is merged multiple times in the output Observable.</p><dl><dt>parameter innerObservable</dt><dd><p>An Observable to replace each value from the source Observable.</p></dd></dl><dl><dt>parameter concurrent</dt><dd><p>Maximum number of input Observables being subscribed to concurrently.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits items from the given `innerObservable`</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-mergeScan"><a href="#val-mergeScan" class="anchor"></a><code><span class="keyword">let</span> mergeScan: <span>[ <span>`Observable<span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Promise</span><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Js.Promise.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Repromise</span><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Promise.t(<span class="type-var">'b</span>))</span></span> <span><span>| `Array</span><span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> array(<span class="type-var">'b</span>))</span></span> ]</span> <span>=&gt;</span> <span>seed:<span class="type-var">'b</span></span> <span>=&gt;</span> <span>?&#8288;concurrent:int</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p>Applies an accumulator function over the source Observable where the accumulator function itself returns an Observable, then each intermediate Observable returned is merged into the output Observable.</p><dl><dt>parameter accumulator</dt><dd><p>The accumulator function called on each source value.</p></dd></dl><dl><dt>parameter seed</dt><dd><p>The initial accumulation value.</p></dd></dl><dl><dt>parameter concurrent</dt><dd><p>Maximum number of input Observables being subscribed to concurrently</p></dd></dl><dl><dt>returns</dt><dd><p>An observable of the accumulated values.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-min"><a href="#val-min" class="anchor"></a><code><span class="keyword">let</span> min: unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function)and when source Observable completes it emits a single item: the item with the smallest value.</p><dl><dt>returns</dt><dd><p>An Observable that emits item with the smallest value.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-minWithComparer"><a href="#val-minWithComparer" class="anchor"></a><code><span class="keyword">let</span> minWithComparer: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> float)</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function)and when source Observable completes it emits a single item: the item with the largest value.</p><dl><dt>parameter Optional</dt><dd><p>comparer function that it will use instead of its default to compare the value of two items.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits item with the smallest value.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-multicast"><a href="#val-multicast" class="anchor"></a><code><span class="keyword">let</span> multicast: <span>[ <span>`Subject<span>(Rx_Subject.t(<span class="type-var">'a</span>))</span></span> <span><span>| `SubjectFactory</span><span>(unit <span>=&gt;</span> Rx_Subject.t(<span class="type-var">'a</span>))</span></span> ]</span> <span>=&gt;</span> <span>?&#8288;selector:<span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'b</span>))</span></span> <span>=&gt;</span> <a href="#type-unaryFunction">unaryFunction</a><span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>), Rx_ConnectableObservable.t(<span class="type-var">'a</span>))</span>;</code></dt><dd><p>Returns an Observable that emits the results of invoking a specified selector on items emitted by a ConnectableObservable that shares a single subscription to the underlying stream.</p><dl><dt>parameter subjectOrSubjectFactory</dt><dd><p>Factory function to create an intermediate subject through which the source sequence's elements will be multicasted to the selector function or Subject to push source elements into.</p></dd></dl><dl><dt>parameter selector</dt><dd><p>Optional selector function that can use the multicasted source stream as many times as needed, without causing multiple subscriptions to the source stream Subscribers to the given source will receive all notifications of the source from the time of the subscription forward.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits the results of invoking the selector on the items emitted by a `ConnectableObservable` that shares a single subscription to the underlying stream.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-observeOn"><a href="#val-observeOn" class="anchor"></a><code><span class="keyword">let</span> observeOn: Rx_Scheduler.t <span>=&gt;</span> <span>?&#8288;delay:int</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Re-emits all notifications from source Observable with specified scheduler. Ensure a specific scheduler is used, from outside of an Observable.</p><p>`observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule notifications emitted by the source Observable. It might be useful, if you do not have control over internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.</p><dl><dt>parameter scheduler</dt><dd><p>Scheduler that will be used to reschedule notifications from source Observable.</p></dd></dl><dl><dt>parameter delay</dt><dd><p>Number of milliseconds that states with what delay every notification should be rescheduled.</p></dd></dl><dl><dt>returns</dt><dd><p>Observable that emits the same notifications as the source Observable, but with provided scheduler.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-onErrorResumeNext"><a href="#val-onErrorResumeNext" class="anchor"></a><code><span class="keyword">let</span> onErrorResumeNext: <span>[ <span>`Observable<span>(array(Rx_Observable.Observable.t(<span class="type-var">'b</span>)))</span></span> <span><span>| `Promise</span><span>(array(Js.Promise.t(<span class="type-var">'b</span>)))</span></span> <span><span>| `Repromise</span><span>(array(Promise.t(<span class="type-var">'b</span>)))</span></span> <span><span>| `Array</span><span>(array(array(<span class="type-var">'b</span>)))</span></span> ]</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p>When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one that was passed.</p><dl><dt>parameter observables</dt><dd><p>Observables passed as an array</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits values from source Observable, but - if it errors - subscribes to the next passed Observable and so on, until it completes or runs out of Observables.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-pairwise"><a href="#val-pairwise" class="anchor"></a><code><span class="keyword">let</span> pairwise: unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>)</span>;</code></dt><dd><p>Groups pairs of consecutive emissions together and emits them as an array of two values.</p><dl><dt>returns</dt><dd><p>An Observable of pairs (as arrays) of consecutive values from the source Observable.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span class="keyword">let</span> partition: <span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-unaryFunction">unaryFunction</a><span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>), <span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>), Rx_Observable.Observable.t(<span class="type-var">'a</span>))</span>)</span>;</code></dt><dd><p>Splits the source Observable into two, one with values that satisfy a predicate, and another with values that don't satisfy the predicate</p><dl><dt>parameter predicate</dt><dd><p>A function that evaluates each value emitted by the source Observable.</p></dd></dl><dl><dt>returns</dt><dd><p>Observables tuple: one with values that passed the predicate, and another with values that did not pass the predicate.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-partionn"><a href="#val-partionn" class="anchor"></a><code><span class="keyword">let</span> partionn: <span>(<span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-unaryFunction">unaryFunction</a><span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>), <span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>), Rx_Observable.Observable.t(<span class="type-var">'a</span>))</span>)</span>;</code></dt></dl><dl><dt class="spec external" id="val-publish"><a href="#val-publish" class="anchor"></a><code><span class="keyword">let</span> publish: <span>?&#8288;selector:<span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'b</span>))</span></span> <span>=&gt;</span> <a href="#type-unaryFunction">unaryFunction</a><span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>), Rx_ConnectableObservable.t(<span class="type-var">'b</span>))</span>;</code></dt><dd><p>Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called before it begins emitting items to those Observers that have subscribed to it.</p><dl><dt>parameter Optional</dt><dd><p>selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence.</p></dd></dl><dl><dt>returns</dt><dd><p>A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-publishBehavior"><a href="#val-publishBehavior" class="anchor"></a><code><span class="keyword">let</span> publishBehavior: <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-unaryFunction">unaryFunction</a><span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>), Rx_ConnectableObservable.t(<span class="type-var">'a</span>))</span>;</code></dt><dt class="spec external" id="val-publishLast"><a href="#val-publishLast" class="anchor"></a><code><span class="keyword">let</span> publishLast: unit <span>=&gt;</span> <a href="#type-unaryFunction">unaryFunction</a><span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>), Rx_ConnectableObservable.t(<span class="type-var">'a</span>))</span>;</code></dt><dd><p>Returns a connectable observable sequence that shares a single subscription to the underlying sequence containing only the last notification.</p><p>Similar to <code>@link publish</code>, but it waits until the source observable completes and stores the last emitted value.</p><dl><dt>returns</dt><dd><p>An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-publishReplay"><a href="#val-publishReplay" class="anchor"></a><code><span class="keyword">let</span> publishReplay: <span>?&#8288;bufferSize:int</span> <span>=&gt;</span> <span>?&#8288;windowTime:int</span> <span>=&gt;</span> <span>?&#8288;selectorOrScheduler:<span>[ <span>`Selector<span>(<a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>)</span></span> <span><span>| `Scheduler</span><span>(Rx_Scheduler.t)</span></span> ]</span></span> <span>=&gt;</span> <a href="#type-unaryFunction">unaryFunction</a><span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>), Rx_ConnectableObservable.t(<span class="type-var">'a</span>))</span>;</code></dt><dt class="spec external" id="val-reduce"><a href="#val-reduce" class="anchor"></a><code><span class="keyword">let</span> reduce: <span>(<span class="type-var">'acc</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> <span class="type-var">'acc</span>)</span> <span>=&gt;</span> <span class="type-var">'acc</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'acc</span>)</span>;</code></dt><dd><p>Applies an accumulator function over the source Observable, and returns the accumulated result when the source completes, given an optional seed value.</p><dl><dt>parameter accumulator</dt><dd><p>The accumulator function called on each source value.</p></dd></dl><dl><dt>parameter seed</dt><dd><p>The initial accumulation value.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits a single value that is the result of accumulating the values emitted by the source Observable.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-refCount"><a href="#val-refCount" class="anchor"></a><code><span class="keyword">let</span> refCount: unit <span>=&gt;</span> <a href="#type-unaryFunction">unaryFunction</a><span>(Rx_ConnectableObservable.t(<span class="type-var">'a</span>), Rx_Observable.Observable.t(<span class="type-var">'a</span>))</span>;</code></dt><dd><p>Make a ConnectableObservable behave like a ordinary observable and automates the way you can connect to it.</p><p>Internally it counts the subscriptions to the observable and subscribes (only once) to the source if the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it unsubscribes from the source. This way you can make sure that everything before the *published* refCount has only a single subscription independently of the number of subscribers to the target observable</p></dd></dl><dl><dt class="spec external" id="val-repeat"><a href="#val-repeat" class="anchor"></a><code><span class="keyword">let</span> repeat: <span>?&#8288;count:int</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Returns an Observable that will resubscribe to the source stream when the source stream completes, at most count times.</p><dl><dt>parameter count</dt><dd><p>The number of times the source Observable items are repeated, a count of 0 will yield an empty Observable.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that will resubscribe to the source stream when the source stream completes, at most count times.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-repeatWhen"><a href="#val-repeatWhen" class="anchor"></a><code><span class="keyword">let</span> repeatWhen: <span>(Rx_Observable.Observable.t(<span class="type-var">'error</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'n</span>))</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise this method will resubscribe to the source Observable.</p><dl><dt>parameter notifier</dt><dd><ul><li>Receives an Observable of notifications with which a user can `complete` or `error`, aborting the repetition.</li></ul></dd></dl><dl><dt>returns</dt><dd><p>The source Observable modified with repeat logic</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-retry"><a href="#val-retry" class="anchor"></a><code><span class="keyword">let</span> retry: <span>?&#8288;count:int</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given as a number parameter) rather than propagating the `error` call.</p><dl><dt>parameter count</dt><dd><p>Number of retry attempts before failing.</p></dd></dl><dl><dt>returns</dt><dd><p>The source Observable modified with the retry logic.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-retryWhen"><a href="#val-retryWhen" class="anchor"></a><code><span class="keyword">let</span> retryWhen: <span>(Rx_Observable.Observable.t(<span class="type-var">'error</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'n</span>))</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`. If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child subscription. Otherwise this method will resubscribe to the source Observable.</p><dl><dt>parameter notifier</dt><dd><p>Receives an Observable of notifications with which a user can `complete` or `error`, aborting the retry</p></dd></dl><dl><dt>returns</dt><dd><p>The source Observable modified with retry logic.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-sample"><a href="#val-sample" class="anchor"></a><code><span class="keyword">let</span> sample: Rx_Observable.Observable.t(<span class="type-var">'n</span>) <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Emits the most recently emitted value from the source Observable whenever another Observable, the `notifier`, emits.</p><dl><dt>parameter The</dt><dd><p>Observable to use for sampling the source Observable.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits the results of sampling the values emitted by the source Observable whenever the notifier Observable emits value or completes.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-sampleTime"><a href="#val-sampleTime" class="anchor"></a><code><span class="keyword">let</span> sampleTime: int <span>=&gt;</span> <span>?&#8288;scheduler:Rx_Scheduler.t</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Emits the most recently emitted value from the source Observable within periodic time intervals.</p><dl><dt>parameter The</dt><dd><p>sampling period expressed in milliseconds or the time unit determined internally by the optional `scheduler`.</p></dd></dl><dl><dt>parameter scheduler</dt><dd><p>The Scheduler to use for managing the timers that handle the sampling.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits the results of sampling the values emitted by the source Observable at the specified time interval.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-scan"><a href="#val-scan" class="anchor"></a><code><span class="keyword">let</span> scan: <span>(<span class="type-var">'acc</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> <span class="type-var">'acc</span>)</span> <span>=&gt;</span> <span class="type-var">'acc</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'acc</span>)</span>;</code></dt><dd><p>Applies an accumulator function over the source Observable, and returns each intermediate result, with an optional seed value.</p><p>It's like reduce</p><p>}</p><p>, but emits the current accumulation whenever the source emits a value.</p><dl><dt>parameter accumulator</dt><dd><p>The accumulator function called on each source value.</p></dd></dl><dl><dt>parameter seed</dt><dd><p>The initial accumulation value.</p></dd></dl><dl><dt>returns</dt><dd><p>An observable of the accumulated values.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-_sequenceEqual"><a href="#val-_sequenceEqual" class="anchor"></a><code><span class="keyword">let</span> _sequenceEqual: Rx_Observable.Observable.t(<span class="type-var">'a</span>) <span>=&gt;</span> <span>comparator:<span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> bool)</span></span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, bool)</span>;</code></dt></dl><dl><dt class="spec value" id="val-sequenceEqual"><a href="#val-sequenceEqual" class="anchor"></a><code><span class="keyword">let</span> sequenceEqual: Rx_Observable.Observable.t(<span class="type-var">'a</span>) <span>=&gt;</span> <span>?&#8288;comparator:<span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> bool)</span></span> <span>=&gt;</span> unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, bool)</span>;</code></dt><dd><p>Compares all values of two observables in sequence using an optional comparator function and returns an observable of a single boolean value representing whether or not the two sequences are equal.</p><dl><dt>parameter compareTo</dt><dd><p>The observable sequence to compare the source sequence to.</p></dd></dl><dl><dt>parameter comparator</dt><dd><p>An optional function to compare each value pair</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable of a single boolean value representing whether or not the values emitted by both observables were equal in sequence.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-share"><a href="#val-share" class="anchor"></a><code><span class="keyword">let</span> share: unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`. This is an alias for obs |&gt; Rx.Operators.multicast(`SubjectFactory(() =&gt; Rx.Subject.create()), ()) |&gt; Rx.Operators.refCount()`.</p><dl><dt>returns</dt><dd><p>An Observable that upon connection causes the source Observable to emit items to its Observers.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-shareReplay"><a href="#val-shareReplay" class="anchor"></a><code><span class="keyword">let</span> shareReplay: <span>?&#8288;bufferSize:int</span> <span>=&gt;</span> <span>?&#8288;windowTime:int</span> <span>=&gt;</span> <span>?&#8288;scheduler:Rx_Scheduler.t</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Share source and replay specified number of emissions on subscription.</p><p>This operator is a specialization of `replay` that connects to a source observable and multicasts through a `ReplaySubject` constructed with the specified arguments. A successfully completed source will stay cached in the `shareReplayed observable` forever, but an errored source can be retried.</p><dl><dt>parameter bufferSize</dt><dd><p>Maximum element count of the replay buffer.</p></dd></dl><dl><dt>parameter windowTime</dt><dd><p>Maximum time length of the replay buffer in milliseconds.</p></dd></dl><dl><dt>parameter scheduler</dt><dd><p>Scheduler where connected observers within the selector function will be invoked on.</p></dd></dl><dl><dt>returns</dt><dd><p>An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-_single"><a href="#val-_single" class="anchor"></a><code><span class="keyword">let</span> _single: <span>predicate:<span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'a</span>) <span>=&gt;</span> bool)</span></span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt></dl><dl><dt class="spec value" id="val-single"><a href="#val-single" class="anchor"></a><code><span class="keyword">let</span> single: <span>?&#8288;predicate:<span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'a</span>) <span>=&gt;</span> bool)</span></span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p>Returns an Observable that emits the single item emitted by the source Observable that matches a specified predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no items, notify of an IllegalArgumentException or NoSuchElementException respectively. If the source Observable emits items but none match the specified predicate then `undefined` is emitted.</p><p>Like first, but emit with error notification if there is more than one value</p></dd></dl><dl><dt class="spec external" id="val-skip"><a href="#val-skip" class="anchor"></a><code><span class="keyword">let</span> skip: int <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Returns an Observable that skips the first `count` items emitted by the source Observable.</p><dl><dt>parameter The</dt><dd><p>number of times, items emitted by source Observable should be skipped.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that skips values emitted by the source Observable.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-skipLast"><a href="#val-skipLast" class="anchor"></a><code><span class="keyword">let</span> skipLast: int <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Skip the last `count` values emitted by the source Observable.</p><dl><dt>parameter count</dt><dd><p>Number of elements to skip from the end of the source Observable.</p></dd></dl><dl><dt>parameter An</dt><dd><p>Observable that skips the last count values emitted by the source Observable.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-skipUntil"><a href="#val-skipUntil" class="anchor"></a><code><span class="keyword">let</span> skipUntil: Rx_Observable.Observable.t(<span class="type-var">'n</span>) <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.</p><p>The `skipUntil` operator causes the observable stream to skip the emission of values ​​until the passed in observable emits the first value. This can be particularly useful in combination with user interactions, responses of http requests or waiting for specific times to pass by.</p><dl><dt>parameter The</dt><dd><p>second Observable that has to emit an item before the source Observable's elements begin to be mirrored by the resulting Observable.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that skips items from the source Observable until the second Observable emits an item, then emits the remaining items.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-skipWhile"><a href="#val-skipWhile" class="anchor"></a><code><span class="keyword">let</span> skipWhile: <span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds true, but emits all further source items as soon as the condition becomes false.</p><dl><dt>parameter predicate</dt><dd><p>A function to test each item emitted from the source Observable.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that begins emitting items emitted by the source Observable when the specified predicate becomes false.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-skipWhilen"><a href="#val-skipWhilen" class="anchor"></a><code><span class="keyword">let</span> skipWhilen: <span>(<span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt></dl><dl><dt class="spec external" id="val-startWith"><a href="#val-startWith" class="anchor"></a><code><span class="keyword">let</span> startWith: array(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Returns an Observable that emits the items you specify as arguments before it begins to emit items emitted by the source Observable.</p><dl><dt>parameter Items</dt><dd><p>you want the modified Observable to emit first</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits the items in the specified Iterable and then emits the items emitted by the source Observable.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-subscribeOn"><a href="#val-subscribeOn" class="anchor"></a><code><span class="keyword">let</span> subscribeOn: Rx_Scheduler.t <span>=&gt;</span> <span>?&#8288;delay:int</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Asynchronously subscribes Observers to this Observable on the specified Scheduler With subscribeOn you can decide what type of scheduler a specific Observable will be using when it is subscribed to.</p><dl><dt>parameter The</dt><dd><p>SchedulerLike to perform subscription actions on.</p></dd></dl><dl><dt>parameter delay</dt><dd><p>delay</p></dd></dl><dl><dt>returns</dt><dd><p>The source Observable modified so that its subscriptions happen on the specified Scheduler</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-switchAllObservable"><a href="#val-switchAllObservable" class="anchor"></a><code><span class="keyword">let</span> switchAllObservable: unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>), <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Converts a higher-order Observable into a first-order Observable producing values only from the most recent observable sequence</p></dd></dl><dl><dt class="spec external" id="val-switchAllPromise"><a href="#val-switchAllPromise" class="anchor"></a><code><span class="keyword">let</span> switchAllPromise: unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(Js.Promise.t(<span class="type-var">'a</span>), <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Converts a higher-order Observable into a first-order Observable producing values only from the most recent observable sequence</p></dd></dl><dl><dt class="spec external" id="val-switchAllRepromise"><a href="#val-switchAllRepromise" class="anchor"></a><code><span class="keyword">let</span> switchAllRepromise: unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(Promise.t(<span class="type-var">'a</span>), <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Converts a higher-order Observable into a first-order Observable producing values only from the most recent observable sequence</p></dd></dl><dl><dt class="spec external" id="val-switchAllArray"><a href="#val-switchAllArray" class="anchor"></a><code><span class="keyword">let</span> switchAllArray: unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(array(<span class="type-var">'a</span>), <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Converts a higher-order Observable into a first-order Observable producing values only from the most recent observable sequence</p></dd></dl><dl><dt class="spec external" id="val-switchMap"><a href="#val-switchMap" class="anchor"></a><code><span class="keyword">let</span> switchMap: <span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'b</span>))</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt><dd><p>Projects each source value to an Observable which is merged in the output Observable, emitting values only from the most recently projected Observable.</p><dl><dt>parameter A</dt><dd><p>function that, when applied to an item emitted by the source Observable, returns an Observable.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits the result of applying the projection function (and the optional deprecated `resultSelector`) to each item emitted by the source Observable and taking only the values from the most recently projected inner Observable.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-switchMapn"><a href="#val-switchMapn" class="anchor"></a><code><span class="keyword">let</span> switchMapn: <span>(<span class="type-var">'a</span> <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'b</span>))</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>;</code></dt></dl><dl><dt class="spec external" id="val-switchMapTo"><a href="#val-switchMapTo" class="anchor"></a><code><span class="keyword">let</span> switchMapTo: <span>[ <span>`Observable<span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>))</span></span> <span><span>| `Promise</span><span>(Js.Promise.t(<span class="type-var">'a</span>))</span></span> <span><span>| `Repromise</span><span>(Promise.t(<span class="type-var">'a</span>))</span></span> <span><span>| `Array</span><span>(array(<span class="type-var">'a</span>))</span></span> ]</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'b</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Projects each source value to the same Observable which is flattened multiple times with switchMap in the output Observable.</p><dl><dt>parameter innerObservable</dt><dd><p>An Observable to replace each value from the source Observable.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits items from the given `innerObservable` (and optionally transformed through the deprecated `resultSelector` every time a value is emitted on the source Observable, and taking only the values from the most recently projected inner Observable.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-take"><a href="#val-take" class="anchor"></a><code><span class="keyword">let</span> take: int <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Emits only the first `count` values emitted by the source Observable.</p><dl><dt>parameter count</dt><dd><p>The maximum number of `next` values to emit.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits only the first `count` values emitted by the source Observable, or all of the values from the source if the source emits fewer than `count` values.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-takeLast"><a href="#val-takeLast" class="anchor"></a><code><span class="keyword">let</span> takeLast: int <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Emits only the last `count` values emitted by the source Observable.</p><dl><dt>parameter count</dt><dd><p>The maximum number of values to emit from the end of the sequence of values emitted by the source Observable.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits at most the last count values emitted by the source Observable.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-takeUntil"><a href="#val-takeUntil" class="anchor"></a><code><span class="keyword">let</span> takeUntil: Rx_Observable.Observable.t(<span class="type-var">'n</span>) <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Emits the values emitted by the source Observable until a `notifier` Observable emits a value.</p><p>Lets values pass until a second Observable, `notifier`, emits a value. Then, it completes.</p><dl><dt>parameter notifier</dt><dd><p>The Observable whose first emitted value will cause the output Observable of `takeUntil` to stop emitting values from the source Observable.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits the values from the source Observable until such time as `notifier` emits its first value.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-takeWhile"><a href="#val-takeWhile" class="anchor"></a><code><span class="keyword">let</span> takeWhile: <span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> bool)</span> <span>=&gt;</span> <span>?&#8288;inclusive:bool</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Emits values emitted by the source Observable so long as each value satisfies the given `predicate`, and then completes as soon as this `predicate` is not satisfied.</p><dl><dt>parameter predicate</dt><dd><p>A function that evaluates a value emitted by the source Observable and returns a boolean. Also takes the (zero-based) index as the second argument.</p></dd></dl><dl><dt>parameter inclusive</dt><dd><p>When set to `true` the value that caused `predicate` to return `false` will also be emitted.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that emits the values from the source Observable so long as each value satisfies the condition defined by the `predicate`, then completes.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-takeWhilen"><a href="#val-takeWhilen" class="anchor"></a><code><span class="keyword">let</span> takeWhilen: <span>(<span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <span>?&#8288;inclusive:bool</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt></dl><dl><dt class="spec external" id="val-_tap"><a href="#val-_tap" class="anchor"></a><code><span class="keyword">let</span> _tap: <span>next:<span>(<span class="type-var">'a</span> <span>=&gt;</span> unit)</span></span> <span>=&gt;</span> <span>error:<span>(<span class="type-var">'e</span> <span>=&gt;</span> unit)</span></span> <span>=&gt;</span> <span>complete:<span>(unit <span>=&gt;</span> unit)</span></span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt></dl><dl><dt class="spec value" id="val-tap"><a href="#val-tap" class="anchor"></a><code><span class="keyword">let</span> tap: <span>?&#8288;next:<span>(<span class="type-var">'a</span> <span>=&gt;</span> unit)</span></span> <span>=&gt;</span> <span>?&#8288;error:<span>(<span class="type-var">'b</span> <span>=&gt;</span> unit)</span></span> <span>=&gt;</span> <span>?&#8288;complete:<span>(unit <span>=&gt;</span> unit)</span></span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Perform a side effect for every emission on the source Observable, but return an Observable that is identical to the source.</p><p>Intercepts each emission on the source and runs a function, but returns an output which is identical to the source as long as errors don't occur.</p><dl><dt>parameter next</dt><dd><p>a callback for `next`.</p></dd></dl><dl><dt>parameter error</dt><dd><p>Callback for errors in the source.</p></dd></dl><dl><dt>parameter complete</dt><dd><p>Callback for the completion of the source.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable identical to the source, but runs the specified callback(s) for each item.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-tapObserver"><a href="#val-tapObserver" class="anchor"></a><code><span class="keyword">let</span> tapObserver: Rx_Types.Observer.t<span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Perform a side effect for every emission on the source Observable, but return an Observable that is identical to the source.</p><p>Intercepts each emission on the source and runs a function, but returns an output which is identical to the source as long as errors don't occur.</p><dl><dt>parameter observer</dt><dd><p>A normal Observer object</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable identical to the source, but runs the specified Observer for each item.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-throttle"><a href="#val-throttle" class="anchor"></a><code><span class="keyword">let</span> throttle: <span>[ <span>`Subscribable<span>(<span class="type-var">'a</span> <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'a</span>))</span></span> <span><span>| `Promise</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> Js.Promise.t(<span class="type-var">'a</span>))</span></span> <span><span>| `Repromise</span><span>(<span class="type-var">'a</span> <span>=&gt;</span> Promise.t(<span class="type-var">'a</span>))</span></span> ]</span> <span>=&gt;</span> <span>?&#8288;config:Rx_Types.ThrottleConfig.t</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Emits a value from the source Observable, then ignores subsequent source values for a duration determined by another Observable, then repeats this process.</p><dl><dt>parameter durationSelector</dt><dd><p>A function that receives a value from the source Observable, for computing the silencing duration for each source value, returned as an Observable or a Promise.</p></dd></dl><dl><dt>parameter config</dt><dd><p>a configuration object to define `leading` and `trailing` behavior. Defaults to <code> leading: true, trailing: false</code>.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that performs the throttle operation to limit the rate of emissions from the source.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-throttleTime"><a href="#val-throttleTime" class="anchor"></a><code><span class="keyword">let</span> throttleTime: <span>duration:int</span> <span>=&gt;</span> <span>?&#8288;scheduler:Rx_Scheduler.t</span> <span>=&gt;</span> <span>?&#8288;config:Rx_Types.ThrottleConfig.t</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Emits a value from the source Observable, then ignores subsequent source values for `duration` milliseconds, then repeats this process.</p><p>Lets a value pass, then ignores source values for the next `duration` milliseconds.</p><dl><dt>parameter duration</dt><dd><p>Time to wait before emitting another value after emitting the last value, measured in milliseconds or the time unit determined internally by the optional `scheduler`.</p></dd></dl><dl><dt>parameter The</dt><dd><p>Scheduler to use for managing the timers that handle the throttling.</p></dd></dl><dl><dt>parameter config</dt><dd><p>a configuration object to define `leading` and `trailing` behavior. Defaults to <code> leading: true, trailing: false</code>.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable that performs the throttle operation to limit the rate of emissions from the source.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-throwIfEmpty"><a href="#val-throwIfEmpty" class="anchor"></a><code><span class="keyword">let</span> throwIfEmpty: <span>(unit <span>=&gt;</span> <span class="type-var">'err</span>)</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>If the source observable completes without emitting a value, it will emit an error. The error will be created at that time by the `errorFactor` argument</p><dl><dt>parameter A</dt><dd><p>factory function called to produce the error to be thrown when the source observable completes without emitting a value.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-timeInterval"><a href="#val-timeInterval" class="anchor"></a><code><span class="keyword">let</span> timeInterval: <span>?&#8288;scheduler:Rx_Scheduler.t</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, Rx_Types.TimeInterval.t(<span class="type-var">'a</span>))</span>;</code></dt><dd><p>Emits an object containing the current value, and the time that has passed between emitting the current value and the previous value, which is calculated by using the provided `scheduler`'s `now()` method to retrieve the current time at each emission, then calculating the difference. The `scheduler` defaults to syncScheduler, so by default, the `interval` will be in milliseconds.</p><dl><dt>parameter scheduler</dt><dd><p>Scheduler used to get the current time.</p></dd></dl><dl><dt>returns</dt><dd><p>Observable that emit infomation about value and interval</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-timeout"><a href="#val-timeout" class="anchor"></a><code><span class="keyword">let</span> timeout: <span>[ <span>`Number<span>(int)</span></span> <span><span>| `Date</span><span>(Js.Date.t)</span></span> ]</span> <span>=&gt;</span> <span>?&#8288;scheduler:Rx_Scheduler.t</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Errors if Observable does not emit a value in given time span. Timeouts on Observable that doesn't emit values fast enough.</p><dl><dt>parameter due</dt><dd><p>Number specifying period within which Observable must emit values or Date specifying before when Observable should complete</p></dd></dl><dl><dt>parameter scheduler</dt><dd><p>Scheduler controlling when timeout checks occur.</p></dd></dl><dl><dt>returns</dt><dd><p>Observable that mirrors behaviour of source, unless timeout checks fail.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-timeoutWith"><a href="#val-timeoutWith" class="anchor"></a><code><span class="keyword">let</span> timeoutWith: <span>due:<span>[ <span>`Number<span>(int)</span></span> <span><span>| `Date</span><span>(Js.Date.t)</span></span> ]</span></span> <span>=&gt;</span> <span>withObservable:<span>[ <span>`Observable<span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>))</span></span> <span><span>| `Promise</span><span>(Js.Promise.t(<span class="type-var">'a</span>))</span></span> <span><span>| `Repromise</span><span>(Promise.t(<span class="type-var">'a</span>))</span></span> <span><span>| `Array</span><span>(array(<span class="type-var">'a</span>))</span></span> ]</span></span> <span>=&gt;</span> <span>?&#8288;scheduler:Rx_Scheduler.t</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span>;</code></dt><dd><p>Errors if Observable does not emit a value in given time span, in case of which subscribes to the second Observable.</p><p>It's a version of `timeout` operator that let's you specify fallback Observable.</p><dl><dt>parameter due</dt><dd><p>Number specifying period within which Observable must emit values or Date specifying before when Observable should complete</p></dd></dl><dl><dt>parameter withObservable</dt><dd><p>Observable which will be subscribed if source fails timeout check.</p></dd></dl><dl><dt>returns</dt><dd><p>Observable that mirrors behaviour of source or, when timeout check fails, of an Observable passed as a second parameter.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-timestamp"><a href="#val-timestamp" class="anchor"></a><code><span class="keyword">let</span> timestamp: <span>?&#8288;scheduler:Rx_Scheduler.t</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, Rx_Types.Timestamp.t(<span class="type-var">'a</span>))</span>;</code></dt><dd><p>Attaches a timestamp to each item emitted by an observable indicating when it was emitted</p><p>The `timestamp` operator maps the *source* observable stream to an object of type `</p><pre>alue: T, timestamp: R}`. The properties are generically typed. The `value` property contains the value
  and type of the *source* observable. The `timestamp` is generated by the schedulers `now` function. By
  default it uses the *async* scheduler which simply returns `Date.now()`
  (milliseconds since 1970/01/01 00:00:00:000) and therefore is of type `number`.</pre></dd></dl><dl><dt class="spec external" id="val-toArray"><a href="#val-toArray" class="anchor"></a><code><span class="keyword">let</span> toArray: unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, array(<span class="type-var">'a</span>))</span>;</code></dt><dd><p>Collects all source emissions and emits them as an array when the source completes.</p><dl><dt>returns</dt><dd><p>An array from an observable sequence.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-window"><a href="#val-window" class="anchor"></a><code><span class="keyword">let</span> window: Rx_Observable.Observable.t(<span class="type-var">'n</span>) <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, Rx_Observable.Observable.t(<span class="type-var">'a</span>))</span>;</code></dt><dd><p>Branch out the source Observable values as a nested Observable whenever `windowBoundaries` emits.</p><dl><dt>parameter windowBoundaries</dt><dd><p>An Observable that completes the previous window and starts a new window.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable of windows, which are Observables emitting values of the source Observable.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-windowCount"><a href="#val-windowCount" class="anchor"></a><code><span class="keyword">let</span> windowCount: int <span>=&gt;</span> <span>?&#8288;startWindowEvery:int</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, Rx_Observable.Observable.t(<span class="type-var">'a</span>))</span>;</code></dt><dd><p>Branch out the source Observable values as a nested Observable with each nested Observable emitting at most `windowSize` values.</p><p>It's like bufferCount, but emits a nested Observable instead of an array.</p><dl><dt>parameter windowSize</dt><dd><p>The maximum number of values emitted by each window.</p></dd></dl><dl><dt>returns</dt><dd><p>An Observable of windows, which in turn are Observable of values.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-windowTime"><a href="#val-windowTime" class="anchor"></a><code><span class="keyword">let</span> windowTime: <span>windowTimeSpan:int</span> <span>=&gt;</span> <span>windowCreationTimeInterval:int</span> <span>=&gt;</span> <span>maxWindowSize:int</span> <span>=&gt;</span> <span>?&#8288;scheduler:Rx_Scheduler.t</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, Rx_Observable.Observable.t(<span class="type-var">'a</span>))</span>;</code></dt><dd><p>Branch out the source Observable values as a nested Observable periodically in time.</p><p>It's like bufferTime, but emits a nested Observable instead of an array.</p><dl><dt>parameter windowTimeSpan</dt><dd><p>The amount of time to fill each window.</p></dd></dl><dl><dt>parameter windowCreationInterval</dt><dd><p>The interval at which to start new windows.</p></dd></dl><dl><dt>parameter maxWindowSize</dt><dd><p>Max number of values each window can emit before completion.</p></dd></dl><dl><dt>parameter scheduler</dt><dd><p>The scheduler on which to schedule the intervals that determine window boundaries.</p></dd></dl><dl><dt>returns</dt><dd><p>An observable of windows, which in turn are Observables.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-windowToggle"><a href="#val-windowToggle" class="anchor"></a><code><span class="keyword">let</span> windowToggle: <span>opening:Rx_Observable.Observable.t(<span class="type-var">'o</span>)</span> <span>=&gt;</span> <span>closingSelector:<span>(<span class="type-var">'o</span> <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'s</span>))</span></span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, Rx_Observable.Observable.t(<span class="type-var">'a</span>))</span>;</code></dt><dd><p>Branch out the source Observable values as a nested Observable starting from an emission from `openings` and ending when the output of `closingSelector` emits.</p><p>It's like bufferToggle, but emits a nested Observable instead of an array.</p><dl><dt>parameter openings</dt><dd><p>An observable of notifications to start new windows.</p></dd></dl><dl><dt>parameter closingSelector</dt><dd><p>A function that takes the value emitted by the `openings` observable and returns an Observable, which, when it emits (either `next` or `complete`), signals that the associated window should complete.</p></dd></dl><dl><dt>returns</dt><dd><p>An observable of windows, which in turn are Observables.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-windowWhen"><a href="#val-windowWhen" class="anchor"></a><code><span class="keyword">let</span> windowWhen: <span>(<span class="type-var">'o</span> <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'s</span>))</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, Rx_Observable.Observable.t(<span class="type-var">'a</span>))</span>;</code></dt><dd><p>Branch out the source Observable values as a nested Observable using a factory function of closing Observables to determine when to start a new window.</p><dl><dt>parameter closingSelector</dt><dd><p>A function that takes no arguments and returns an Observable that signals (on either `next` or `complete`) when to close the previous window and start a new one.</p></dd></dl><dl><dt>returns</dt><dd><p>An observable of windows, which in turn are Observables.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-withLatestFrom"><a href="#val-withLatestFrom" class="anchor"></a><code><span class="keyword">let</span> withLatestFrom: array(Rx_Observable.Observable.t(<span class="type-var">'a</span>)) <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, array(<span class="type-var">'a</span>))</span>;</code></dt><dd><p>Combines the source Observable with other Observables to create an Observable whose values are calculated from the latest values of each, only when the source emits.</p><dl><dt>parameter other</dt><dd><p>An input Observable array to combine with the source Observable. An Observable of projected values from the most recent values from each input Observable, or an array of the most recent values from each input Observable.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-withLatestFrom2"><a href="#val-withLatestFrom2" class="anchor"></a><code><span class="keyword">let</span> withLatestFrom2: Rx_Observable.Observable.t(<span class="type-var">'b</span>) <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>)</span>;</code></dt><dt class="spec external" id="val-withLatestFrom3"><a href="#val-withLatestFrom3" class="anchor"></a><code><span class="keyword">let</span> withLatestFrom3: Rx_Observable.Observable.t(<span class="type-var">'b</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'c</span>) <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>)</span>)</span>;</code></dt><dt class="spec external" id="val-withLatestFrom4"><a href="#val-withLatestFrom4" class="anchor"></a><code><span class="keyword">let</span> withLatestFrom4: Rx_Observable.Observable.t(<span class="type-var">'b</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'c</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'d</span>) <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span>)</span>;</code></dt><dt class="spec external" id="val-withLatestFrom5"><a href="#val-withLatestFrom5" class="anchor"></a><code><span class="keyword">let</span> withLatestFrom5: Rx_Observable.Observable.t(<span class="type-var">'b</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'c</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'d</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'e</span>) <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>)</span>)</span>;</code></dt><dt class="spec external" id="val-withLatestFrom6"><a href="#val-withLatestFrom6" class="anchor"></a><code><span class="keyword">let</span> withLatestFrom6: Rx_Observable.Observable.t(<span class="type-var">'b</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'c</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'d</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'e</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'f</span>) <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>)</span>)</span>;</code></dt><dt class="spec external" id="val-withLatestFrom7"><a href="#val-withLatestFrom7" class="anchor"></a><code><span class="keyword">let</span> withLatestFrom7: Rx_Observable.Observable.t(<span class="type-var">'b</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'c</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'d</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'e</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'f</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'g</span>) <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>, <span class="type-var">'g</span>)</span>)</span>;</code></dt><dt class="spec external" id="val-withLatestFrom8"><a href="#val-withLatestFrom8" class="anchor"></a><code><span class="keyword">let</span> withLatestFrom8: Rx_Observable.Observable.t(<span class="type-var">'b</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'c</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'d</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'e</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'f</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'g</span>) <span>=&gt;</span> Rx_Observable.Observable.t(<span class="type-var">'h</span>) <span>=&gt;</span> <a href="#type-operator">operator</a><span>(<span class="type-var">'a</span>, <span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>, <span class="type-var">'g</span>, <span class="type-var">'h</span>)</span>)</span>;</code></dt><dt class="spec external" id="val-zipAll"><a href="#val-zipAll" class="anchor"></a><code><span class="keyword">let</span> zipAll: unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>), array(<span class="type-var">'a</span>))</span>;</code></dt><dt class="spec external" id="val-zipAllPromise"><a href="#val-zipAllPromise" class="anchor"></a><code><span class="keyword">let</span> zipAllPromise: unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(Js.Promise.t(<span class="type-var">'a</span>), array(<span class="type-var">'a</span>))</span>;</code></dt><dt class="spec external" id="val-zipAllRepromise"><a href="#val-zipAllRepromise" class="anchor"></a><code><span class="keyword">let</span> zipAllRepromise: unit <span>=&gt;</span> <a href="#type-operator">operator</a><span>(Promise.t(<span class="type-var">'a</span>), array(<span class="type-var">'a</span>))</span>;</code></dt><dt class="spec external" id="val-_zipAllProject"><a href="#val-_zipAllProject" class="anchor"></a><code><span class="keyword">let</span> _zipAllProject: Js.Internal.fn<span>(<span>[ <span>`Arity_1<span>(array(<span class="type-var">'a</span>) <span>=&gt;</span> <span class="type-var">'r</span>)</span></span> ]</span>, <a href="#type-operator">operator</a><span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>), <span class="type-var">'r</span>)</span>)</span>;</code></dt></dl><dl><dt class="spec value" id="val-zipAllProject"><a href="#val-zipAllProject" class="anchor"></a><code><span class="keyword">let</span> zipAllProject: <a href="#type-projectFn">projectFn</a><span>(array(<span class="type-var">'a</span>), <span class="type-var">'r</span>)</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(Rx_Observable.Observable.t(<span class="type-var">'a</span>), <span class="type-var">'r</span>)</span>;</code></dt></dl><dl><dt class="spec external" id="val-_zipAllPromiseProject"><a href="#val-_zipAllPromiseProject" class="anchor"></a><code><span class="keyword">let</span> _zipAllPromiseProject: Js.Internal.fn<span>(<span>[ <span>`Arity_1<span>(array(<span class="type-var">'a</span>) <span>=&gt;</span> <span class="type-var">'r</span>)</span></span> ]</span>, <a href="#type-operator">operator</a><span>(Js.Promise.t(<span class="type-var">'a</span>), <span class="type-var">'r</span>)</span>)</span>;</code></dt></dl><dl><dt class="spec value" id="val-zipAllPromiseProject"><a href="#val-zipAllPromiseProject" class="anchor"></a><code><span class="keyword">let</span> zipAllPromiseProject: <a href="#type-projectFn">projectFn</a><span>(array(<span class="type-var">'a</span>), <span class="type-var">'r</span>)</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(Js.Promise.t(<span class="type-var">'a</span>), <span class="type-var">'r</span>)</span>;</code></dt></dl><dl><dt class="spec external" id="val-_zipAllRepromiseProject"><a href="#val-_zipAllRepromiseProject" class="anchor"></a><code><span class="keyword">let</span> _zipAllRepromiseProject: Js.Internal.fn<span>(<span>[ <span>`Arity_1<span>(array(<span class="type-var">'a</span>) <span>=&gt;</span> <span class="type-var">'r</span>)</span></span> ]</span>, <a href="#type-operator">operator</a><span>(Promise.t(<span class="type-var">'a</span>), <span class="type-var">'r</span>)</span>)</span>;</code></dt></dl><dl><dt class="spec value" id="val-zipAllRepromiseProject"><a href="#val-zipAllRepromiseProject" class="anchor"></a><code><span class="keyword">let</span> zipAllRepromiseProject: <a href="#type-projectFn">projectFn</a><span>(array(<span class="type-var">'a</span>), <span class="type-var">'r</span>)</span> <span>=&gt;</span> <a href="#type-operator">operator</a><span>(Promise.t(<span class="type-var">'a</span>), <span class="type-var">'r</span>)</span>;</code></dt></dl></div></body></html>